<!-- <!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>AI Sales Trainer</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        .mic-active { animation: pulse 1.5s infinite; background-color: #dc3545 !important; }
        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(220, 53, 69, 0); } 100% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0); } }
    </style>
</head>
<body class="bg-light">

<div class="container py-5">
    <h1 class="mb-4 text-center">ğŸ¤ å–¶æ¥­ãƒ­ãƒ¼ãƒ—ãƒ¬ AIã‚³ãƒ¼ãƒ</h1>
    
    <div class="row justify-content-center">
        <div class="col-md-8">
            <div class="card shadow-sm mb-4">
                <div class="card-body text-center">
                    <h5 class="card-title">ã‚»ãƒ¼ãƒ«ã‚¹ãƒˆãƒ¼ã‚¯ã‚’éŒ²éŸ³</h5>
                    <button id="recordBtn" class="btn btn-primary btn-lg rounded-pill px-5">
                        éŒ²éŸ³é–‹å§‹
                    </button>
                    <p id="status" class="mt-3 text-muted">å¾…æ©Ÿä¸­...</p>
                </div>
            </div>

            <div class="card shadow-sm mb-4">
                <div class="card-header">ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ¥ç¶šãƒ­ã‚° (/ws/realtime)</div>
                <div class="card-body bg-dark text-white" style="height: 150px; overflow-y: auto;" id="wsLog">
                </div>
            </div>

            <div class="card shadow-sm">
                <div class="card-header bg-success text-white">AI ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯</div>
                <div class="card-body">
                    <div id="feedbackContent">éŒ²éŸ³å®Œäº†å¾Œã«ã“ã“ã«è©•ä¾¡ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚</div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    let mediaRecorder;
    let audioChunks = [];
    let isRecording = false;
    const recordBtn = document.getElementById('recordBtn');
    const status = document.getElementById('status');
    const wsLog = document.getElementById('wsLog');
    
    // WebSocketæ¥ç¶š
    const socket = new WebSocket(`ws://${location.host}/ws/realtime`);
    socket.onopen = () => log("WebSocket Connected");
    socket.onmessage = (e) => log("AI: " + e.data);

    function log(msg) {
        const div = document.createElement('div');
        div.textContent = `> ${msg}`;
        wsLog.appendChild(div);
        wsLog.scrollTop = wsLog.scrollHeight;
    }

    recordBtn.addEventListener('click', async () => {
        if (!isRecording) {
            // éŒ²éŸ³é–‹å§‹
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            mediaRecorder = new MediaRecorder(stream);
            audioChunks = [];

            mediaRecorder.ondataavailable = event => {
                audioChunks.push(event.data);
                // WebSocketã¸ã‚‚ãƒ‡ãƒ¼ã‚¿é€ä¿¡ï¼ˆãƒ‡ãƒ¢ç”¨ï¼‰
                if(socket.readyState === WebSocket.OPEN) socket.send("Audio Chunk Sent");
            };

            mediaRecorder.onstop = async () => {
                const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                status.textContent = "ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ä¸­...";
                await handleUploadAndFeedback(audioBlob);
            };

            mediaRecorder.start(1000); // 1ç§’ã”ã¨ã«ãƒãƒ£ãƒ³ã‚¯ä½œæˆ
            isRecording = true;
            recordBtn.textContent = "éŒ²éŸ³åœæ­¢";
            recordBtn.classList.add('mic-active');
            status.textContent = "éŒ²éŸ³ä¸­...";
        } else {
            // éŒ²éŸ³åœæ­¢
            mediaRecorder.stop();
            isRecording = false;
            recordBtn.textContent = "éŒ²éŸ³é–‹å§‹";
            recordBtn.classList.remove('mic-active');
        }
    });

    async function handleUploadAndFeedback(blob) {
        try {
            // 1. ç½²åä»˜ãURLå–å¾—
            const signRes = await fetch('/sign-upload', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({filename: 'practice.webm', contentType: 'audio/webm'})
            });
            const signData = await signRes.json();

            // 2. GCSã¸ç›´æ¥ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
            await fetch(signData.upload_url, {
                method: 'PUT',
                headers: {'Content-Type': 'audio/webm'},
                body: blob
            });
            status.textContent = "AIè©•ä¾¡ä¸­...";

            // 3. è©•ä¾¡ãƒªã‚¯ã‚¨ã‚¹ãƒˆ
            const feedRes = await fetch('/feedback', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({gcs_uri: signData.gcs_uri})
            });
            const feedData = await feedRes.json();

            // 4. çµæœè¡¨ç¤º
            document.getElementById('feedbackContent').innerHTML = marked.parse(feedData.feedback || "ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ");
            status.textContent = "å®Œäº†";
        } catch (e) {
            console.error(e);
            status.textContent = "ã‚¨ãƒ©ãƒ¼: " + e.message;
        }
    }
</script>
</body>
</html> -->
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>AIå–¶æ¥­ãƒ­ãƒ¼ãƒ—ãƒ¬ Live</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        .talking { box-shadow: 0 0 15px #0d6efd; border-color: #0d6efd; }
        .listening { box-shadow: 0 0 15px #198754; border-color: #198754; animation: pulse 1s infinite; }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.02); } 100% { transform: scale(1); } }
        #chat-area { height: 300px; overflow-y: auto; background: #f8f9fa; border: 1px solid #ddd; padding: 15px; border-radius: 5px; }
        .msg-user { text-align: right; color: #0d6efd; margin: 5px; }
        .msg-ai { text-align: left; color: #198754; margin: 5px; font-weight: bold; }
    </style>
</head>
<body class="bg-light">

<div class="container py-5">
    <h2 class="text-center mb-4">ğŸ“ AIé¡§å®¢ã¨ã®ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ å•†è«‡</h2>
    
    <div class="row justify-content-center">
        <div class="col-md-8">
            <div class="card shadow-sm mb-4">
                <div class="card-body text-center">
                    <p class="text-muted">ãƒã‚¤ã‚¯ã‚’ONã«ã—ã¦ã€ã€Œã“ã‚“ã«ã¡ã¯ã€ã¨è©±ã—ã‹ã‘ã¦ãã ã•ã„ã€‚</p>
                    <button id="connectBtn" class="btn btn-primary btn-lg rounded-pill px-5">
                        å•†è«‡é–‹å§‹ï¼ˆæ¥ç¶šï¼‰
                    </button>
                    <button id="disconnectBtn" class="btn btn-danger btn-lg rounded-pill px-5 d-none">
                        å•†è«‡çµ‚äº†
                    </button>
                    <div id="status" class="mt-3 badge bg-secondary">åˆ‡æ–­ä¸­</div>
                </div>
            </div>

            <div class="card shadow-sm mb-4">
                <div class="card-header">ä¼šè©±ãƒ­ã‚°</div>
                <div id="chat-area"></div>
            </div>

            <div class="card shadow-sm">
                <div class="card-header bg-dark text-white">ä¸Šå¸ã‹ã‚‰ã®ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯</div>
                <div class="card-body">
                    <div id="feedbackContent">å•†è«‡çµ‚äº†å¾Œã«è©•ä¾¡ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚</div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    let socket;
    let audioContext;
    let processor;
    let inputSource;
    let audioQueue = [];
    let isPlaying = false;
    let conversationLog = []; // è©•ä¾¡ç”¨ã«ãƒ­ã‚°ã‚’è²¯ã‚ã‚‹

    const connectBtn = document.getElementById('connectBtn');
    const disconnectBtn = document.getElementById('disconnectBtn');
    const status = document.getElementById('status');
    const chatArea = document.getElementById('chat-area');

    // â–  éŸ³å£°å‡¦ç†: Base64å¤‰æ›
    function arrayBufferToBase64(buffer) {
        let binary = '';
        const bytes = new Uint8Array(buffer);
        const len = bytes.byteLength;
        for (let i = 0; i < len; i++) {
            binary += String.fromCharCode(bytes[i]);
        }
        return window.btoa(binary);
    }

    // â–  éŸ³å£°å‡¦ç†: PCM16å¤‰æ› (Geminiç”¨)
    function floatTo16BitPCM(input) {
        const output = new Int16Array(input.length);
        for (let i = 0; i < input.length; i++) {
            const s = Math.max(-1, Math.min(1, input[i]));
            output[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
        }
        return output.buffer;
    }

    // â–  æ¥ç¶šé–‹å§‹
    connectBtn.addEventListener('click', async () => {
        try {
            status.textContent = "æ¥ç¶šä¸­...";
            
            // 1. WebSocketæ¥ç¶š
            const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            socket = new WebSocket(`${protocol}//${location.host}/ws/realtime`);

            socket.onopen = async () => {
                status.textContent = "é€šè©±ä¸­ (Listening...)";
                status.className = "mt-3 badge bg-success listening";
                connectBtn.classList.add('d-none');
                disconnectBtn.classList.remove('d-none');
                
                // ãƒã‚¤ã‚¯é–‹å§‹
                await startMicrophone();
            };

            socket.onmessage = async (event) => {
                const response = JSON.parse(event.data);
                
                // AIã®éŸ³å£°å—ä¿¡ (serverContent -> modelTurn -> parts -> inlineData)
                if (response.serverContent?.modelTurn?.parts) {
                    for (const part of response.serverContent.modelTurn.parts) {
                        if (part.inlineData && part.inlineData.mimeType.startsWith('audio')) {
                            // éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã®å†ç”Ÿ
                            const audioData = atob(part.inlineData.data);
                            const arrayBuffer = new Uint8Array(audioData.length);
                            for(let i=0; i<audioData.length; i++) arrayBuffer[i] = audioData.charCodeAt(i);
                            playAudio(arrayBuffer.buffer);
                        }
                        // ãƒ†ã‚­ã‚¹ãƒˆãŒã‚ã‚Œã°ãƒ­ã‚°ã«è¿½åŠ 
                        if (part.text) {
                            addLog("AI", part.text);
                        }
                    }
                }
            };

            socket.onclose = () => {
                stopMicrophone();
                status.textContent = "çµ‚äº†";
                status.className = "mt-3 badge bg-secondary";
            };

        } catch (e) {
            console.error(e);
            alert("æ¥ç¶šã‚¨ãƒ©ãƒ¼: " + e.message);
        }
    });

    // â–  åˆ‡æ–­ï¼†è©•ä¾¡ãƒªã‚¯ã‚¨ã‚¹ãƒˆ
    disconnectBtn.addEventListener('click', async () => {
        socket.close();
        stopMicrophone();
        connectBtn.classList.remove('d-none');
        disconnectBtn.classList.add('d-none');
        
        // è©•ä¾¡APIã‚’å‘¼ã¶
        status.textContent = "AIè©•ä¾¡ä¸­...";
        const logText = conversationLog.map(l => `${l.role}: ${l.text}`).join("\n");
        
        try {
            const res = await fetch('/feedback', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ log: logText || "ï¼ˆéŸ³å£°å¯¾è©±ã®ãŸã‚è©³ç´°ãƒ­ã‚°ãªã—ã€‚é›°å›²æ°—ã§è©•ä¾¡ã—ã¦ãã ã•ã„ï¼‰" })
            });
            const data = await res.json();
            document.getElementById('feedbackContent').innerHTML = marked.parse(data.feedback);
            status.textContent = "å®Œäº†";
        } catch(e) {
            status.textContent = "è©•ä¾¡ã‚¨ãƒ©ãƒ¼";
        }
    });

    // â–  ãƒã‚¤ã‚¯å…¥åŠ›å‡¦ç†
    async function startMicrophone() {
        audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 24000 });
        const stream = await navigator.mediaDevices.getUserMedia({ audio: { channelCount: 1, sampleRate: 24000 } });
        inputSource = audioContext.createMediaStreamSource(stream);
        
        // AudioWorkletãŒç†æƒ³ã§ã™ãŒã€ç°¡ç•¥åŒ–ã®ãŸã‚ScriptProcessorã‚’ä½¿ç”¨
        processor = audioContext.createScriptProcessor(4096, 1, 1);
        
        inputSource.connect(processor);
        processor.connect(audioContext.destination);

        processor.onaudioprocess = (e) => {
            if (socket.readyState !== WebSocket.OPEN) return;
            
            const inputData = e.inputBuffer.getChannelData(0);
            // PCM16å¤‰æ›
            const pcmData = floatTo16BitPCM(inputData);
            // Base64å¤‰æ›
            const base64Audio = arrayBufferToBase64(pcmData);

            // Geminiã¸ã®é€ä¿¡ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å½¢å¼
            const msg = {
                realtime_input: {
                    media_chunks: [{
                        mime_type: "audio/pcm",
                        data: base64Audio
                    }]
                }
            };
            socket.send(JSON.stringify(msg));
        };
    }

    function stopMicrophone() {
        if (inputSource) inputSource.disconnect();
        if (processor) processor.disconnect();
        if (audioContext) audioContext.close();
    }

    // â–  AIéŸ³å£°ã®å†ç”Ÿ
    async function playAudio(arrayBuffer) {
        // PCM 24kHz (Geminiã®å‡ºåŠ›ä»•æ§˜) ã‚’å†ç”Ÿ
        // ç°¡æ˜“å®Ÿè£…: éŸ³å£°ã‚­ãƒ¥ãƒ¼ã«è¿½åŠ ã—ã¦é †æ¬¡å†ç”Ÿ
        // æ³¨: æœ¬æ ¼çš„ã«ã¯AudioWorkletã§ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ å†ç”ŸãŒå¿…è¦
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 24000 });
        // PCMãƒ‡ãƒ¼ã‚¿ã‚’AudioBufferã«å¤‰æ›
        const pcm16 = new Int16Array(arrayBuffer);
        const float32 = new Float32Array(pcm16.length);
        for(let i=0; i<pcm16.length; i++) float32[i] = pcm16[i] / 32768;

        const buffer = audioCtx.createBuffer(1, float32.length, 24000);
        buffer.getChannelData(0).set(float32);

        const source = audioCtx.createBufferSource();
        source.buffer = buffer;
        source.connect(audioCtx.destination);
        source.start();
        
        // ç°¡æ˜“ãƒ­ã‚°è¡¨ç¤ºï¼ˆéŸ³å£°ãŒæ¥ãŸã“ã¨ã ã‘è¡¨ç¤ºï¼‰
        addLog("AI", "ï¼ˆéŸ³å£°ç™ºè©±ä¸­...ï¼‰");
    }

    function addLog(role, text) {
        // é‡è¤‡æ’é™¤ï¼ˆç°¡æ˜“ï¼‰
        if(conversationLog.length > 0 && conversationLog[conversationLog.length-1].text === text) return;

        const div = document.createElement('div');
        div.className = role === "User" ? "msg-user" : "msg-ai";
        div.textContent = `${role}: ${text}`;
        chatArea.appendChild(div);
        chatArea.scrollTop = chatArea.scrollHeight;
        
        conversationLog.push({role, text});
    }
</script>
</body>
</html>