<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>AIå–¶æ¥­ãƒ­ãƒ¼ãƒ—ãƒ¬ Live (Rec & Eval)</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        .listening { animation: pulse 1.5s infinite; border: 2px solid #198754; }
        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(25, 135, 84, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(25, 135, 84, 0); } 100% { box-shadow: 0 0 0 0 rgba(25, 135, 84, 0); } }
        #chat-area { height: 400px; overflow-y: auto; background: #f8f9fa; border: 1px solid #ddd; padding: 15px; border-radius: 5px; }
        .msg-user { text-align: right; color: #0d6efd; margin: 5px; font-weight: bold; }
        .msg-ai { text-align: left; color: #198754; margin: 5px; font-weight: bold; }
    </style>
</head>
<body class="bg-light">

<div class="container py-5">
    <h2 class="text-center mb-4">ğŸ“ AIé¡§å®¢ã¨ã®ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ å•†è«‡</h2>
    
    <div class="row justify-content-center">
        <div class="col-md-8">
            <div class="card shadow-sm mb-4">
                <div class="card-body text-center">
                    <p class="text-muted">ãƒã‚¤ã‚¯ã‚’ONã«ã—ã¦è©±ã—ã‹ã‘ã¦ãã ã•ã„</p>
                    <button id="connectBtn" class="btn btn-primary btn-lg rounded-pill px-5">
                        å•†è«‡é–‹å§‹ï¼ˆæ¥ç¶šï¼‰
                    </button>
                    <button id="disconnectBtn" class="btn btn-danger btn-lg rounded-pill px-5 d-none">
                        å•†è«‡çµ‚äº†
                    </button>
                    <div id="status" class="mt-3 badge bg-secondary">å¾…æ©Ÿä¸­</div>
                </div>
            </div>

            <div class="card shadow-sm mb-4">
                <div class="card-header">ä¼šè©±ãƒ­ã‚° (è‡ªåˆ†ã®å£°)</div>
                <div id="chat-area"></div>
            </div>

            <div class="card shadow-sm">
                <div class="card-header bg-dark text-white">ä¸Šå¸ã‹ã‚‰ã®ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯</div>
                <div class="card-body">
                    <div id="feedbackContent">å•†è«‡çµ‚äº†å¾Œã«ã€AIã®å£°ã‚’åˆ†æã—ã¦ã“ã“ã«è©•ä¾¡ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚</div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    let socket;
    let audioContext;
    let processor;
    let inputSource;
    let conversationLog = []; // è‡ªåˆ†ã®ç™ºè¨€ãƒ­ã‚°
    let recognition;
    let nextStartTime = 0;
    
    // â˜…è¿½åŠ : AIã®éŸ³å£°ã‚’è²¯ã‚ã¦ãŠãé…åˆ—
    let aiAudioChunks = []; 

    const connectBtn = document.getElementById('connectBtn');
    const disconnectBtn = document.getElementById('disconnectBtn');
    const status = document.getElementById('status');
    const chatArea = document.getElementById('chat-area');

    // â–¼ WAVãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆç”¨é–¢æ•° (PCMãƒ‡ãƒ¼ã‚¿ã‹ã‚‰WAVãƒ˜ãƒƒãƒ€ã‚’ç”Ÿæˆ)
    function exportWAV(pcmData, sampleRate) {
        const buffer = new ArrayBuffer(44 + pcmData.length * 2);
        const view = new DataView(buffer);

        // RIFF header
        writeString(view, 0, 'RIFF');
        view.setUint32(4, 36 + pcmData.length * 2, true);
        writeString(view, 8, 'WAVE');
        writeString(view, 12, 'fmt ');
        view.setUint32(16, 16, true);
        view.setUint16(20, 1, true); // PCM
        view.setUint16(22, 1, true); // Mono
        view.setUint32(24, sampleRate, true);
        view.setUint32(28, sampleRate * 2, true);
        view.setUint16(32, 2, true);
        view.setUint16(34, 16, true);
        writeString(view, 36, 'data');
        view.setUint32(40, pcmData.length * 2, true);

        // PCM Data
        for (let i = 0; i < pcmData.length; i++) {
            view.setInt16(44 + i * 2, pcmData[i], true);
        }

        return new Blob([view], { type: 'audio/wav' });
    }

    function writeString(view, offset, string) {
        for (let i = 0; i < string.length; i++) {
            view.setUint8(offset + i, string.charCodeAt(i));
        }
    }

    // â–¼ éŸ³å£°èªè­˜
    // â–¼â–¼â–¼ éŸ³å£°èªè­˜ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ— (æ”¹è‰¯ç‰ˆ) â–¼â–¼â–¼
    function setupSpeechRecognition() {
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!SpeechRecognition) {
            console.error("éŸ³å£°èªè­˜éå¯¾å¿œã®ãƒ–ãƒ©ã‚¦ã‚¶ã§ã™");
            return null;
        }
        
        const rec = new SpeechRecognition();
        rec.lang = 'ja-JP';
        rec.continuous = true; // é€£ç¶šèªè­˜ãƒ¢ãƒ¼ãƒ‰
        rec.interimResults = false; // ç¢ºå®šã—ãŸçµæœã®ã¿å–å¾—

        // è©±ã—ãŸè¨€è‘‰ã‚’ãƒ­ã‚°ã«è¿½åŠ 
        rec.onresult = (event) => {
            const last = event.results.length - 1;
            const text = event.results[last][0].transcript;
            console.log("èªè­˜çµæœ:", text); // ç¢ºèªç”¨ãƒ­ã‚°
            if (text.trim() !== "") {
                addLog("User", text);
            }
        };

        // â˜…è¿½åŠ : ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸå ´åˆ
        rec.onerror = (event) => {
            console.error("éŸ³å£°èªè­˜ã‚¨ãƒ©ãƒ¼:", event.error);
            if (event.error === 'not-allowed') {
                alert("ãƒã‚¤ã‚¯ã®ä½¿ç”¨ãŒè¨±å¯ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚");
            }
        };

        // â˜…è¿½åŠ : èªè­˜ãŒæ­¢ã¾ã£ãŸã‚‰è‡ªå‹•ã§å†é–‹ã™ã‚‹ (é‡è¦ï¼)
        rec.onend = () => {
            // å•†è«‡ä¸­ï¼ˆã‚½ã‚±ãƒƒãƒˆãŒã¤ãªãŒã£ã¦ã„ã‚‹ï¼‰ãªã‚‰ã€ã™ãã«å†é–‹ã•ã›ã‚‹
            if (socket && socket.readyState === WebSocket.OPEN) {
                console.log("éŸ³å£°èªè­˜ãŒä¸­æ–­ã•ã‚Œã¾ã—ãŸã€‚å†é–‹ã—ã¾ã™...");
                try {
                    rec.start();
                } catch(e) {
                    console.error("å†é–‹ã‚¨ãƒ©ãƒ¼:", e);
                }
            }
        };

        return rec;
    }

    // â–¼ æ¥ç¶šé–‹å§‹
    connectBtn.addEventListener('click', async () => {
        try {
            status.textContent = "æ¥ç¶šä¸­...";
            aiAudioChunks = []; // ãƒªã‚»ãƒƒãƒˆ
            
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 24000 });
            } else if (audioContext.state === 'suspended') {
                await audioContext.resume();
            }
            nextStartTime = audioContext.currentTime;

            const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            socket = new WebSocket(`${protocol}//${location.host}/ws/realtime`);

            socket.onopen = async () => {
                status.textContent = "é€šè©±ä¸­";
                status.className = "mt-3 badge bg-success listening";
                connectBtn.classList.add('d-none');
                disconnectBtn.classList.remove('d-none');
                
                await startMicrophone();
                recognition = setupSpeechRecognition();
                if(recognition) recognition.start();
            };

            socket.onmessage = async (event) => {
                try {
                    let textData;
                    if (event.data instanceof Blob) textData = await event.data.text();
                    else textData = event.data;
                    
                    const response = JSON.parse(textData);
                    if (response.serverContent?.modelTurn?.parts) {
                        for (const part of response.serverContent.modelTurn.parts) {
                            if (part.inlineData && part.inlineData.mimeType.startsWith('audio')) {
                                // éŸ³å£°å†ç”Ÿï¼†ä¿å­˜
                                const audioStr = atob(part.inlineData.data);
                                playAndRecordAudio(audioStr);
                            }
                        }
                    }
                } catch (e) { console.error(e); }
            };

            socket.onclose = () => stopAll();
        } catch (e) { alert("Error: " + e.message); }
    });

    // â–¼ åˆ‡æ–­ï¼†è©•ä¾¡ (ã“ã“ãŒé‡è¦ï¼)
    disconnectBtn.addEventListener('click', async () => {
        stopAll();
        status.textContent = "AIéŸ³å£°åˆ†æãƒ»è©•ä¾¡ä¸­...";
        status.className = "mt-3 badge bg-warning text-dark";
        
        // 1. è²¯ã‚ãŸéŸ³å£°ãƒ‡ãƒ¼ã‚¿ã‚’çµåˆ
        const totalLength = aiAudioChunks.reduce((acc, chunk) => acc + chunk.length, 0);
        const mergedAudio = new Int16Array(totalLength);
        let offset = 0;
        for (const chunk of aiAudioChunks) {
            mergedAudio.set(chunk, offset);
            offset += chunk.length;
        }

        // 2. WAVãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆ
        const wavBlob = exportWAV(mergedAudio, 24000);

        // 3. ãƒ•ã‚©ãƒ¼ãƒ ãƒ‡ãƒ¼ã‚¿ä½œæˆ
        const formData = new FormData();
        const logText = conversationLog.map(l => `${l.role}: ${l.text}`).join("\n");
        formData.append('log', logText);
        formData.append('audio', wavBlob, 'ai_response.wav'); // ãƒ•ã‚¡ã‚¤ãƒ«ã¨ã—ã¦æ·»ä»˜

        // 4. é€ä¿¡
        try {
            const res = await fetch('/feedback', {
                method: 'POST',
                body: formData // JSONã§ã¯ãªãFormDataã§é€ã‚‹
            });
            const data = await res.json();
            document.getElementById('feedbackContent').innerHTML = marked.parse(data.feedback);
            status.textContent = "å®Œäº†";
            status.className = "mt-3 badge bg-secondary";
        } catch(e) {
            status.textContent = "è©•ä¾¡ã‚¨ãƒ©ãƒ¼";
            console.error(e);
        }
    });

    function stopAll() {
        if(socket) socket.close();
        stopMicrophone();
        if(recognition) recognition.stop();
        connectBtn.classList.remove('d-none');
        disconnectBtn.classList.add('d-none');
        status.textContent = "å¾…æ©Ÿä¸­";
        status.className = "mt-3 badge bg-secondary";
    }

    // â–¼ ãƒã‚¤ã‚¯å…¥åŠ› (Float32 -> Int16å¤‰æ›)
    async function startMicrophone() {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: { channelCount: 1, sampleRate: 24000 } });
        inputSource = audioContext.createMediaStreamSource(stream);
        // ãƒãƒƒãƒ•ã‚¡ã‚µã‚¤ã‚ºã‚’ 4096 -> 1024 ã«å¤‰æ›´ã—ã¦é…å»¶ã‚’çŸ­ç¸® (ç´„170ms -> 42ms)
        processor = audioContext.createScriptProcessor(1024, 1, 1);
        inputSource.connect(processor);
        processor.connect(audioContext.destination);

        processor.onaudioprocess = (e) => {
            if (!socket || socket.readyState !== WebSocket.OPEN) return;
            const inputData = e.inputBuffer.getChannelData(0);
            const output = new Int16Array(inputData.length);
            for (let i = 0; i < inputData.length; i++) {
                const s = Math.max(-1, Math.min(1, inputData[i]));
                output[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
            }
            
            // Base64å¤‰æ›
            let binary = '';
            const bytes = new Uint8Array(output.buffer);
            for (let i = 0; i < bytes.byteLength; i++) binary += String.fromCharCode(bytes[i]);
            const base64Audio = window.btoa(binary);

            socket.send(JSON.stringify({
                realtime_input: { media_chunks: [{ mime_type: "audio/pcm", data: base64Audio }] }
            }));
        };
    }

    function stopMicrophone() {
        if (inputSource) inputSource.disconnect();
        if (processor) processor.disconnect();
    }

    // â–¼ AIéŸ³å£°å†ç”Ÿï¼†ä¿å­˜
    async function playAndRecordAudio(base64String) {
        if (!base64String) return;

        const audioData = new Uint8Array(base64String.length);
        for(let i=0; i<base64String.length; i++) audioData[i] = base64String.charCodeAt(i);
        
        if (!audioContext) return;
        const pcm16 = new Int16Array(audioData.buffer);
        if (pcm16.length === 0) return;

        // â˜…ä¿å­˜: å¾Œã§é€ã‚‹ãŸã‚ã«é…åˆ—ã«è¿½åŠ 
        aiAudioChunks.push(pcm16);

        // â˜…å†ç”Ÿ: AudioContextã§æµã™
        const float32 = new Float32Array(pcm16.length);
        for(let i=0; i<pcm16.length; i++) float32[i] = pcm16[i] / 32768;

        const buffer = audioContext.createBuffer(1, float32.length, 24000);
        buffer.getChannelData(0).set(float32);

        const source = audioContext.createBufferSource();
        source.buffer = buffer;
        source.connect(audioContext.destination);

        if (nextStartTime < audioContext.currentTime) nextStartTime = audioContext.currentTime;
        source.start(nextStartTime);
        nextStartTime += buffer.duration;
    }

    function addLog(role, text) {
        const div = document.createElement('div');
        div.className = role === "User" ? "msg-user" : "msg-ai";
        div.textContent = text;
        chatArea.appendChild(div);
        chatArea.scrollTop = chatArea.scrollHeight;
        conversationLog.push({role, text});
    }
</script>
</body>
</html>