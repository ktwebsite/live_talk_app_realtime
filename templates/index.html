<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>AIå–¶æ¥­ãƒ­ãƒ¼ãƒ—ãƒ¬ Live (Stable)</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        .listening { animation: pulse 1.5s infinite; border: 2px solid #198754; }
        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(25, 135, 84, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(25, 135, 84, 0); } 100% { box-shadow: 0 0 0 0 rgba(25, 135, 84, 0); } }
        #chat-area { height: 400px; overflow-y: auto; background: #f8f9fa; border: 1px solid #ddd; padding: 15px; border-radius: 5px; }
        .msg-user { text-align: right; color: #0d6efd; margin: 5px; font-weight: bold; }
        .msg-ai { text-align: left; color: #198754; margin: 5px; font-weight: bold; }
        .msg-system { text-align: center; color: #999; font-size: 0.8rem; margin: 10px 0; }
    </style>
</head>
<body class="bg-light">

<div class="container py-5">
    <h2 class="text-center mb-4">ğŸ“ AIé¡§å®¢ã¨ã®ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ å•†è«‡</h2>
    
    <div class="row justify-content-center">
        <div class="col-md-8">
            <div class="card shadow-sm mb-4">
                <div class="card-body text-center">
                    <p class="text-muted">ãƒã‚¤ã‚¯ã‚’ONã«ã—ã¦è©±ã—ã‹ã‘ã¦ãã ã•ã„</p>
                    <button id="connectBtn" class="btn btn-primary btn-lg rounded-pill px-5">
                        å•†è«‡é–‹å§‹ï¼ˆæ¥ç¶šï¼‰
                    </button>
                    <button id="disconnectBtn" class="btn btn-danger btn-lg rounded-pill px-5 d-none">
                        å•†è«‡çµ‚äº†
                    </button>
                    <div id="status" class="mt-3 badge bg-secondary">å¾…æ©Ÿä¸­</div>
                </div>
            </div>

            <div class="card shadow-sm mb-4">
                <div class="card-header">ä¼šè©±ãƒ­ã‚°</div>
                <div id="chat-area"></div>
            </div>

            <div class="card shadow-sm">
                <div class="card-header bg-dark text-white">ä¸Šå¸ã‹ã‚‰ã®ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯</div>
                <div class="card-body">
                    <div id="feedbackContent">å•†è«‡çµ‚äº†å¾Œã«è©•ä¾¡ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚</div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    let socket;
    let audioContext;
    let processor;
    let inputSource;
    let conversationLog = []; 
    let recognition; // éŸ³å£°èªè­˜ç”¨

    const connectBtn = document.getElementById('connectBtn');
    const disconnectBtn = document.getElementById('disconnectBtn');
    const status = document.getElementById('status');
    const chatArea = document.getElementById('chat-area');

    // â–¼â–¼â–¼ éŸ³å£°èªè­˜ (ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®è¨€è‘‰ã‚’æ–‡å­—ã«ã™ã‚‹) â–¼â–¼â–¼
    function setupSpeechRecognition() {
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!SpeechRecognition) return null;
        
        const rec = new SpeechRecognition();
        rec.lang = 'ja-JP';
        rec.continuous = true;
        rec.interimResults = false;

        rec.onresult = (event) => {
            const last = event.results.length - 1;
            const text = event.results[last][0].transcript;
            if (text.trim() !== "") {
                addLog("User", text);
            }
        };
        return rec;
    }

    // â–¼â–¼â–¼ éŸ³å£°å‡¦ç†ç”¨é–¢æ•° â–¼â–¼â–¼
    function arrayBufferToBase64(buffer) {
        let binary = '';
        const bytes = new Uint8Array(buffer);
        for (let i = 0; i < bytes.byteLength; i++) binary += String.fromCharCode(bytes[i]);
        return window.btoa(binary);
    }

    function floatTo16BitPCM(input) {
        const output = new Int16Array(input.length);
        for (let i = 0; i < input.length; i++) {
            const s = Math.max(-1, Math.min(1, input[i]));
            output[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
        }
        return output.buffer;
    }

    // â–  æ¥ç¶šé–‹å§‹
    connectBtn.addEventListener('click', async () => {
        try {
            status.textContent = "æ¥ç¶šä¸­...";
            
            // 1. AudioContext (å†åˆ©ç”¨)
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 24000 });
            } else if (audioContext.state === 'suspended') {
                await audioContext.resume();
            }

            // 2. WebSocketæ¥ç¶š
            const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            socket = new WebSocket(`${protocol}//${location.host}/ws/realtime`);

            socket.onopen = async () => {
                status.textContent = "é€šè©±ä¸­";
                status.className = "mt-3 badge bg-success listening";
                connectBtn.classList.add('d-none');
                disconnectBtn.classList.remove('d-none');
                
                // ãƒã‚¤ã‚¯é–‹å§‹ (Geminiã¸é€ä¿¡)
                await startMicrophone();

                // éŸ³å£°èªè­˜é–‹å§‹ (ç”»é¢è¡¨ç¤º)
                recognition = setupSpeechRecognition();
                if(recognition) recognition.start();
            };

            // 3. å—ä¿¡å‡¦ç† (Blobå¯¾å¿œ & ç©ºãƒ‡ãƒ¼ã‚¿å¯¾ç­–)
            socket.onmessage = async (event) => {
                try {
                    let textData;
                    if (event.data instanceof Blob) {
                        textData = await event.data.text();
                    } else {
                        textData = event.data;
                    }
                    
                    const response = JSON.parse(textData);
                    
                    if (response.serverContent?.modelTurn?.parts) {
                        for (const part of response.serverContent.modelTurn.parts) {
                            // éŸ³å£°ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Œã°å†ç”Ÿ
                            if (part.inlineData && part.inlineData.mimeType.startsWith('audio')) {
                                const audioStr = atob(part.inlineData.data);
                                playAudio(audioStr);
                            }
                            // ãƒ†ã‚­ã‚¹ãƒˆãŒã‚ã‚Œã°è¡¨ç¤º (ç¾åœ¨ã¯è¨­å®šã«ã‚ˆã‚Šæ¥ãªã„ãŒã€å¿µã®ãŸã‚)
                            if (part.text) {
                                addLog("AI", part.text);
                            }
                        }
                    }
                } catch (e) {
                    console.error("å—ä¿¡ã‚¨ãƒ©ãƒ¼:", e);
                }
            };

            socket.onclose = () => stopAll();
            socket.onerror = (e) => {
                console.error(e);
                alert("æ¥ç¶šã‚¨ãƒ©ãƒ¼ã€‚ãƒªãƒ­ãƒ¼ãƒ‰ã—ã¦å†è©¦è¡Œã—ã¦ãã ã•ã„ã€‚");
                stopAll();
            };

        } catch (e) {
            console.error(e);
            alert("ã‚¨ãƒ©ãƒ¼: " + e.message);
        }
    });

    // â–  åˆ‡æ–­ï¼†è©•ä¾¡
    disconnectBtn.addEventListener('click', async () => {
        stopAll();
        
        status.textContent = "è©•ä¾¡ä½œæˆä¸­...";
        status.className = "mt-3 badge bg-warning text-dark";
        
        // ãƒ­ã‚°ã‚’æ•´å½¢ã—ã¦é€ä¿¡
        const logText = conversationLog.map(l => `${l.role}: ${l.text}`).join("\n");
        
        try {
            const res = await fetch('/feedback', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ log: logText || "ï¼ˆéŸ³å£°ã®ã¿ã®å¯¾è©±ã§ã—ãŸï¼‰" })
            });
            const data = await res.json();
            document.getElementById('feedbackContent').innerHTML = marked.parse(data.feedback);
            status.textContent = "å®Œäº†";
            status.className = "mt-3 badge bg-secondary";
        } catch(e) {
            status.textContent = "è©•ä¾¡ã‚¨ãƒ©ãƒ¼";
        }
    });

    function stopAll() {
        if(socket) socket.close();
        stopMicrophone();
        if(recognition) recognition.stop();
        
        connectBtn.classList.remove('d-none');
        disconnectBtn.classList.add('d-none');
        status.textContent = "å¾…æ©Ÿä¸­";
        status.className = "mt-3 badge bg-secondary";
    }

    // â–  ãƒã‚¤ã‚¯å…¥åŠ›
    async function startMicrophone() {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: { channelCount: 1, sampleRate: 24000 } });
        inputSource = audioContext.createMediaStreamSource(stream);
        processor = audioContext.createScriptProcessor(4096, 1, 1);
        
        inputSource.connect(processor);
        processor.connect(audioContext.destination);

        processor.onaudioprocess = (e) => {
            if (!socket || socket.readyState !== WebSocket.OPEN) return;
            
            const inputData = e.inputBuffer.getChannelData(0);
            const pcmData = floatTo16BitPCM(inputData);
            const base64Audio = arrayBufferToBase64(pcmData);

            socket.send(JSON.stringify({
                realtime_input: {
                    media_chunks: [{
                        mime_type: "audio/pcm",
                        data: base64Audio
                    }]
                }
            }));
        };
    }

    function stopMicrophone() {
        if (inputSource) inputSource.disconnect();
        if (processor) processor.disconnect();
    }

    // â–  éŸ³å£°å†ç”Ÿ (å®‰å…¨æ€§å¼·åŒ–ç‰ˆ)
    async function playAudio(base64String) {
        if (!base64String || base64String.length === 0) return;

        const audioData = new Uint8Array(base64String.length);
        for(let i=0; i<base64String.length; i++) audioData[i] = base64String.charCodeAt(i);
        
        if (!audioContext) return;

        const pcm16 = new Int16Array(audioData.buffer);
        if (pcm16.length === 0) return;

        const float32 = new Float32Array(pcm16.length);
        for(let i=0; i<pcm16.length; i++) float32[i] = pcm16[i] / 32768;

        const buffer = audioContext.createBuffer(1, float32.length, 24000);
        buffer.getChannelData(0).set(float32);

        const source = audioContext.createBufferSource();
        source.buffer = buffer;
        source.connect(audioContext.destination);
        source.start();
    }

    function addLog(role, text) {
        const div = document.createElement('div');
        div.className = role === "User" ? "msg-user" : "msg-ai";
        div.textContent = text;
        chatArea.appendChild(div);
        chatArea.scrollTop = chatArea.scrollHeight;
        conversationLog.push({role, text});
    }
</script>
</body>
</html>